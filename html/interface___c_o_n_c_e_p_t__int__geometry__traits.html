<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>T4 API Reference ALL: _CONCEPT_int_geometry_traits Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="acrobaticon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">T4 API Reference ALL
   &#160;<span id="projectnumber">00.1 Beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('interface___c_o_n_c_e_p_t__int__geometry__traits.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">_CONCEPT_int_geometry_traits Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Traits class providing basic geometric types for the integral coordinate plane.  
 <a href="interface___c_o_n_c_e_p_t__int__geometry__traits.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rastergeometry_8hpp_source.html">rastergeometry.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Traits class providing basic geometric types for the integral coordinate plane. </p>
<p>Basic rasterization services in Haiku require that the application traits class provide a typedef named "int_geometry_traits," which identifies the fundamental data types required for integral geometric operations. "int_geometry_traits" is a traits class that must provide types that Haiku will use for coordinates, points, rectangles and regions. These types are provided through four typedefs, documented below.</p>
<p><b>coord_type</b></p>
<p>Example:</p>
<pre>
<code>
template&lt;typename app_traits&gt;
struct MyIntGeometryTraits
{
    typedef signed long coord_type;
</code>
</pre><p>This is the type to be used to represent all scalar quantities representing distances and coordinates in integer-based geometry. It must match the member type for points and rectangles. It must be a signed integral type with support for all the standard arithmetic operators.</p>
<p>It is not a requirement that the model of the int_geometry_traits concept be a template instantiated on an app_traits parameter. However, we expect that this will be necessary for most implementations, because the region_type member will have a non-trivial destructor, so it will require access to a global context, and will thus need to be instantiated on a client-provided app_traits template parameter.</p>
<p><b>point_type</b></p>
<pre>
<code>
    typedef MyPoint point_type;
</code>
</pre><p>This is the type to be used to represent points on the integral coordinate plane and, occasionally, two-dimensional sizes. This type has the following requirements:</p>
<ol>
<li>
<p class="startli"><b>Regularity:</b> point_type must have a default constructor, a copy constructor, and a copy assignment operator (typically the compiler-generated versions of these are acceptable). A default-constructed point_type may have random initial values.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Accessors:</b> The expressions:</p>
<pre>
<code>
get_x( p );
get_y( p );
</code>
</pre><p class="interli">must return a coord_type (or const reference to a coord_type) when p is a reference to a const point_type. When p is a reference to a non-const point_type, they must return a reference to a non-const coord_type. They should return the x and the y value of the point, respectively. These functions are presumed to be very efficient, and should be inlined. For example:</p>
<pre>
<code>
// This code appears OUTSIDE the definition of MyIntGeometryTraits,
// and should appear inside the namespace that MyPoint is declared in
// (this allows Koenig lookup to work).

inline signed long get_x( const MyPoint&amp; pt )
{
    return pt.m_x;
}

inline signed long get_y( const MyPoint&amp; pt )
{
    return pt.m_y;
}

inline signed long&amp; get_x( MyPoint&amp; pt )
{
    return pt.m_x;
}

inline signed long&amp; get_y( MyPoint&amp; pt )
{
    return pt.m_y;
}
</code>
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli"><b>Coordinate type deduction:</b> Users of a type modeling point_type must provide a specialization of the tetraphilia::PointTypeHelper template which provides a definition of the point_type's coordinate type. For example:</p>
<pre>
<code>
// This code appears OUTSIDE the definition of MyIntGeometryTraits.  The specialization
// must be defined inside the tetraphilia namespace.
namespace tetraphilia {

template&lt;&gt;
struct PointTypeHelper&lt;MyPoint&gt;
{
    typedef signed long coord_type;
}

} // end namespace tetraphilia
</code>
</pre>  </li>
</ol>
<p>This type <em>must</em> match the coord_type typedef in the containing int_geometry_traits.</p>
<p><b>rect_type</b></p>
<pre>
<code>
    typedef MyRect rect_type;
</code>
</pre><p>This is the type to be used to represent rectangular regions on the integral coordinate plane. This type has the following requirements:</p>
<ol>
<li>
<p class="startli"><b>Regularity:</b> rect_type must have a default constructor, a copy constructor, and a copy assignment operator (typically the compiler-generated versions of these are acceptable). A default-constructed rect_type may have random initial values.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Accessors:</b> The expressions:</p>
<pre>
<code>
get_xmin( r );
get_ymin( r );
get_xmax( r );
get_ymax( r );
get_width( r );
get_height( r );
</code>
</pre><p class="interli">must return a coord_type (or const reference to a coord_type) when p is a reference to a const rect_type. Unlike point_type, there is no requirement for non-const accessors. These functions are presumed to be very efficient, and should be inlined. For example:</p>
<pre>
<code>
// This code appears OUTSIDE the definition of MyIntGeometryTraits,
// and should appear inside the namespace that MyRect is declared in
// (this allows Koenig lookup to work).

inline signed long get_xmin( const MyRect&amp; r )
{
    return r.m_topLeft.m_x;
}

inline signed long get_ymin( const MyRect&amp; r )
{
    return r.m_topLeft.m_y;
}

inline signed long get_xmax( const MyRect&amp; r )
{
    return r.m_bottomRight.m_x;
}

inline signed long get_ymax( const MyRect&amp; r )
{
    return r.m_bottomRight.m_y;
}

inline signed long get_width( const MyRect&amp; r )
{
    return r.m_bottomRight.m_x - r.m_topLeft.m_x;
}

inline signed long get_height( const MyRect&amp; r )
{
    return r.m_bottomRight.m_y - r.m_topLeft.m_y;
}
</code>
</pre><p class="interli">To support modification of a rectangle's internally stored values, the following expressions: </p><pre>
<code>
set_xmin( r, val );
set_ymin( r, val );
set_xmax( r, val );
set_ymax( r, val );
set_width( r, val );
set_height( r, val );
</code>
</pre><p class="interli">must modify the given rectangle such that a subsequent query to the corresponding get method returns val (after conversion to a coord_type, if need be). In all of the above expressions r is a reference to a const rect_type and val is of a type convertible to coord_type. <b>Note:</b> calls to set_xmax, set_ymax, set_width and set_height must <em>not</em> modify the result of get_xmin and get_ymin (i.e., these calls should modify the right and bottom edges of the rectangle). For example:</p>
<pre>
<code>
// This code appears OUTSIDE the definition of MyIntGeometryTraits,
// and should appear inside the namespace that MyRect is declared in
// (this allows Koenig lookup to work).

inline void set_xmin( const MyRect&amp; r, signed long val )
{
    r.m_topLeft.m_x = val;
}

inline void set_ymin( const MyRect&amp; r, signed long val )
{
    r.m_topLeft.m_y = val;
}

inline void set_xmax( const MyRect&amp; r, signed long val )
{
    r.m_bottomRight.m_x = val;
}

inline void set_ymax( const MyRect&amp; r, signed long val )
{
    r.m_bottomRight.m_y = val;
}

inline void set_width( const MyRect&amp; r, signed long val )
{
    r.m_bottomRight.m_x = r.m_topLeft.m_x + val;
}

inline void set_height( const MyRect&amp; r, signed long val )
{
    r.m_bottomRight.m_y = r.m_topLeft.m_y + val;
}
</code>
</pre><p class="interli"></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Coordinate type deduction:</b> Users of a type modeling rect_type must provide a specialization of the tetraphilia::RectTypeHelper template which provides a definition of the rect_type's coordinate type. For example:</p>
<pre>
<code>
// This code appears OUTSIDE the definition of MyIntGeometryTraits.  The specialization
// must be defined inside the tetraphilia namespace.
namespace tetraphilia {

template&lt;&gt;
struct RectTypeHelper&lt;MyRect&gt;
{
    typedef signed long coord_type;
}

} // end namespace tetraphilia
</code>
</pre>  </li>
</ol>
<p><b>region_type</b></p>
<pre>
<code>
    typedef MyRegion&lt;app_traits&gt; region_type;
</code>
</pre><p>This is the type to be used to represent arbitrary subsets of the integral coordinate plane. Haiku will use instances of region_type to keep track of screen update regions, which can be arbitrarily shaped. Because the representation of this data structure is likely to require unpredictable (and not formally bounded) amounts of memory, it is very likely that clients will require access to the globals context so that they may integrate successfully with the exception handler. For this reason we expect models of the region_type concept to be templates instantiated on an app_traits template parameter, and descend from the Unwindable class.</p>
<p>It is also expected that the region_type will be a wrapper around an OS-provided region-like object. For example:</p>
<pre>
<code>
template&lt;typename app_traits&gt;
class MyRegion
{
public:

    ... constructors, algebraic operations ...

private:
    HRGN m_hrgn;
};
</code>
</pre><p>The above class is a model for the region_type concept that uses HRGNs. This class will only work on Windows, but it allows Haiku to use regions without rewriting region-handling code that already exists on all platforms.</p>
<p>region_type has the following requirements:</p>
<ol>
<li>
<p class="startli"><b>(Partial) Regularity:</b> region_type must have a copy constructor and a copy assignment operator. It is only "partially" regular because a default constructor is not required (there must exist, however, a constructor taking a reference to an app_traits::context_type, which serves a similar purpose). Also, assignment is (logically) a copy; the following code:</p>
<pre>
<code>
{
    MyRegion&lt;app_traits&gt; a = MakeRegion();
    MyRegion&lt;app_traits&gt; b = a;
    b.Intersect( MakeAnotherRegion() );
}
</code>
</pre><p class="interli">should <em>not</em> modify the region represented by a. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Constructors:</b> region_type must have the following constructors:</p>
<pre>
<code>
    // Constructs an empty region.
    MyRegion&lt;app_traits&gt;::MyRegion( typename app_traits::context_type&amp; context );

    // Copy constructor.
    MyRegion&lt;app_traits&gt;::MyRegion( const region_type&amp; rhs );

    // Construct a region including all the points in the given rectangle.
    // rect_type is specified in the enclosing int_geometry_traits.
    MyRegion&lt;app_traits&gt;::MyRegion( const rect_type&amp; rect );
</code>
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli"><b>Non-throwing swap:</b> a function findable via boost::swap (usually implemented through a friend function) must exist for region_type which is guaranteed not to throw. For example:</p>
<pre>
<code>
template&lt;typename app_traits&gt;
class MyRegion
{
    ...

    template&lt;typename app_traits&gt;
    friend void swap( MyRegion&lt;app_traits&gt;&amp; lhs, MyRegion&lt;app_traits&gt;&amp; rhs )
    {
        boost::swap( lhs.m_bbox, rhs.m_bbox );
        boost::swap( lhs.m_hrgn, rhs.m_hrgn );
    }

    ...
};
</code>
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli"><b>Accessors:</b> region_type must provide the following methods which answer high-level questions about the region's shape:</p>
<pre>
<code>
    // This should return false if the region is non-empty.  Returning true for
    // empty regions is not strictly required, although it will help performance.
    bool IsEmpty( void ) const;

    // This should return a rectangle outside of which the region is zero.  It
    // is not required that this rectangle be "tight."  It is acceptable to return
    // a const int_rect_type&amp; or an int_rect type.
    int_rect_type GetBBox( void ) const;

    // If this function returns true, the client may assume that the region represents
    // a rectangular region whose bounds are exactly the value returned by GetBBox.
    // It is acceptable to return false on rectangular regions, but failure to do so
    // may compromise performance in certain cases.
    bool IsRectangular( void ) const;
</code>
</pre> <p class="endli"></p>
</li>
<li>
<p class="startli"><b>Algebraic operations:</b> region_type must provide the following methods:</p>
<pre>
<code>
    void Intersect( const region_type&amp; rhs );

    void Union( const region_type&amp; rhs );

    void Subtract( const region_type&amp; rhs );
</code>
</pre><p class="interli">These operations are performed "in-place," i.e., they <em>do</em> modify the region on which they are called. After calling Intersect the region will contain only those points inside both rhs and the original region. Union modifies the region so that it contains all points in either rhs or the original region. Subtract removes all points from the original region that are also in rhs.</p>
<p class="interli">It is expected that the implementation of these routines will call similar OS-provided routines on an underlying OS-provided object. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Scaling:</b> region_type must provide the following method:</p>
<pre><code>
    void Scale( typename app_traits::real_geometry_traits::coord_type scale );
</code></pre><p class="interli">This must scale the region's contents by the given scale factor. This cannot be done with perfect mathematical precision, and there are no specific requirements on how the result is computed (e.g., floor vs. round vs. ceiling). The closer the result is to a perfect scaling of the original the more visually pleasing the results will be. One exception is that if the scale is 1, the region should be unchanged.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Region walking support:</b> Haiku requires the ability to "walk" through a region by x and y coordinate. region_type must provide a member typedef called "walker_type" which identifies a stateful data structure capable of iterating through instances of region_type. For example:</p>
<pre>
<code>
    typedef MyRegionWalker walker_type;
</code>
</pre><p class="endli">This type must model the "region walker" concept, below.  </p>
</li>
</ol>
<p><b>region_type::walker_type</b></p>
<p>The "region walker" concept is modeled by types that provide the following features:</p>
<ol>
<li>
<p class="startli"><b>Construction from regions:</b> region walkers are instantiable from constructors taking a single object of the corresponding region_type. For example:</p>
<pre>
<code>
    class MyRegionWalker
    {
    public:
        template&lt;typename app_traits&gt;
        MyRegionWalker( const MyRegionType&lt;app_traits&gt;&amp; region );

        ...
    }
</code>
</pre><p class="interli">Note that in this example MyRegionWalker is not a template on app_traits, but its constructor is. It is perfectly legal for MyRegionWalker to be instantiated on app_traits instead, but in our implementations so far we have found that MyRegionWalker instances have no exception- related semantics, and thus no need for a context or knowledge of the app_traits.</p>
<p class="interli">A "region walker" is always pointing at one particular coordinate (x,y) in the infinite integral coordinate plane. At construction time the initial values of (x,y) are undefined, and the implementation may presume that Inside() and GetXStop() will not be called until they are defined by calls to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> and <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a5aa364a79773656d682601763c42d884">SetX()</a>.</p>
<p class="interli">Any given pixel (x,y) is either "inside" or "outside" the region being walked; the method Inside() returns true if the pixel at (x,y) is included in the region, and false if it is not. Additionally, the GetXStop() method indicates the next pixel to the right of (x,y) at which the value of Inside() changes. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>SetY:</b> the region walker must provide a SetY method with the following signature:</p>
<pre>
<code>
    void SetY( coord_type y );
</code>
</pre><p class="interli">coord_type must match the coord_type member of the enclosing int_geometry_traits structure. SetY sets the y coordinate that the region walker is pointing to. The implementation may let the current value of x become undefined after any call to IncrementY.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>IncrementY:</b> the region walker must provide an IncrementY method with the following signature:</p>
<pre>
<code>
    void IncrementY( void );
</code>
</pre><p class="interli">This should simply increment the current value of y. The implementation is allowed to assume that at least one call to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> will precede the first call to IncrementY. The implementation may also let the current value of x become undefined after any call to IncrementY.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>SetX:</b> the region walker must provide a SetX method with the following signature:</p>
<pre>
<code>
    void SetX( coord_type x );
</code>
</pre><p class="interli">This sets the region walker's current value of x. The implementation may assume that this call was preceded by at least one call to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Inside:</b> a region walker must provide a method named "Inside" with the following signature:</p>
<pre>
<code>
    bool Inside( void ) const;
</code>
</pre><p class="interli">This should return true if the pixel at (x,y) is included inside the region being walked, or false if it is not.</p>
<p class="interli">The implementation may assume that <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> has been called at least once, and that <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a5aa364a79773656d682601763c42d884">SetX()</a> has been called at least once since the most recent call to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> or <a class="el" href="namespacetetraphilia_1_1imaging__model.html#ad07dc2cb22925060a1f07e1071697104">IncrementY()</a>. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>GetXStop:</b> a region walker must provide a method named "GetXStop" with the following signature:</p>
<pre>
<code>
    coord_type GetXStop( void ) const;
</code>
</pre><p class="interli">coord_type is required to be the same type as the coord_type member typedef in the cooresponding int_geometry_traits structure. This function should return the next x coordinate at which the value of Inside() changes. If there is no such coordinate the implementation <em>must</em> return <a class="el" href="structtetraphilia_1_1limits.html#a25d8cd1ad72c2c3b01d3ae49c8f0c708">tetraphilia::limits&lt;coord_type&gt;::max()</a>.</p>
<p class="endli">The implementation may assume that <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> has been called at least once, and that <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a5aa364a79773656d682601763c42d884">SetX()</a> has been called at least once since the most recent call to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a13642f0d427167eef5b8f9037da0bdc4">SetY()</a> or <a class="el" href="namespacetetraphilia_1_1imaging__model.html#ad07dc2cb22925060a1f07e1071697104">IncrementY()</a>.  </p>
</li>
</ol>
</div><hr/>The documentation for this interface was generated from the following file:<ul>
<li>C:/GIT/t4/t4/tetraphilia/imaging_model/<a class="el" href="rastergeometry_8hpp_source.html">rastergeometry.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="interface___c_o_n_c_e_p_t__int__geometry__traits.html">_CONCEPT_int_geometry_traits</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
