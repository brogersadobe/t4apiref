<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>T4 API Reference ALL: _CONCEPT_surface Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="acrobaticon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">T4 API Reference ALL
   &#160;<span id="projectnumber">00.1 Beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('interface___c_o_n_c_e_p_t__surface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">_CONCEPT_surface Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Concept whose models provide blitting services into an offscreen buffer.  
 <a href="interface___c_o_n_c_e_p_t__surface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="surfacesupport_8hpp_source.html">surfacesupport.hpp</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Concept whose models provide blitting services into an offscreen buffer. </p>
<p>Haiku maintains for the client an offscreen buffer containing a (possibly in-progress) rendering of the page, exactly the size of the page view's aperture. This is done because PDF files may be quite complex, and the Haiku engine can keep track of rendering progress at a very fine level, enabling Haiku to provide a very smooth incremental screen update mechanism with very low overhead to the client.</p>
<p>The offscreen buffer's chief use is in sampling its contents to the screen, so it is useful if the offscreen buffer avails itself of system services to the extent that it can. Many platforms provide a data type intended for storage of an offscreen bitmap with memory characteristics optimized for the device.</p>
<p>Furthermore, many environments provide screens with compact screen characteristics, for example, 4 bits per component pixels. While this color resolution is too low for quality PDF rendering, it is not necessary to store a deeper offscreen buffer than this, since composition never happens in the offscreen buffer.</p>
<p>The "Surface" concept exists to allow clients to provide an offscreen buffer type usable by Haiku with a color depth appropriate to the screen, using platform-provided bitmap services.</p>
<p>All instances of models of the surface concept contain a notion of a size, expressed in the application traits' integer coordinates. "Surface space" is the space where the rectangle with this size and origin at (0,0) corresponds to the pixel data contained in the surface. All surface methods use coordinates in this space.</p>
<p>Haiku provides two implementations of the Surface concept, one for Windows using a device compatible HBITMAP, and one for Symbian using CFbsBitmap. It also provides some support classes to make implementation of additional Surface classes easy.</p>
<p>Models of the Surface concept must provide the following:</p>
<p><b>CopyFrom (non-scaling)</b></p>
<p>This method is used to copy subrectangles of data from one instance of a Surface type to another.</p>
<p>Example:</p>
<pre>
<code>
    void CopyFrom( const WinSurface&amp; source, const POINT&amp; srcPoint, const RECT&amp; dstRect ) const
    {
        // Note: HBITMAP does not have a notion of a non-zero top left coordinate, hence
        // the translation by m_bounds' top left corner
        ::BitBlt( m_dc, get_xmin( dstRect ), get_ymin( dstRect ), get_width( dstRect ), get_height( dstRect ),
            source.m_dc, get_x( srcPoint ), get_y( srcPoint ), SRCCOPY );
    }
</code>
</pre><p>CopyFrom copies pixels from the source surface into the surface represented by "this." It copies data into the rectangle (in the destination's surface space) specified by dstRect, and copies from the rectangle of the same size located at srcPoint (in the source's surface space) in the source surface.</p>
<p>There is no guarantee that srcPoint is inside source's bounds, or that dstRect is contained inside the destination's bounds. Pixels should only be modified if they exist in the destination and the corresponding pixel exists in the source.</p>
<p><b>CopyFrom (scaling)</b></p>
<p>This method is used to resample subrectangles of data from one instance of a Surface type to another. The source and destination subrectangles do not need to be the same size.</p>
<pre><code>
    void CopyFrom( const WinSurface&amp; source, const RECT&amp; srcRect, const RECT&amp; dstRect ) const
    {
        ::StretchBlt( m_dc, get_xmin( dstRect ), get_ymin( dstRect ), get_width( dstRect ), get_height( dstRect ),
            source.m_dc, get_xmin( srcRect ), get_ymin( srcRect ), get_width( srcRect ), get_height( srcRect ), SRCCOPY );
    }
</code></pre><p>CopyFrom copies pixels from the source surface inside the srcRect subrectangle into the destination surface inside the dstRect subrectangle. Because srcRect and dstRect may be different sizes, the result may be stretched or compressed in either or both dimensions.</p>
<p>There is no guarantee that srcRect is inside source's bounds, or that dstRect is contained inside the destination's bounds. Pixels should only be modified if they exist in the destination and the corresponding pixel exists in the source.</p>
<p><b>ScrollBy</b></p>
<p>This method is used to scroll the surface by a specified number of pixels in both the x and y direction. After this operation, every pixel at (x+dx, y+dx) must have the value that was stored in (x,y) before the operation, wherever both pixels are inside the surface. All other pixels must remain unchanged.</p>
<p>For platforms that do not support the scrolling of bitmaps, Haiku provides the ScrollSurface function.</p>
<p><b>GetSize</b></p>
<p>Returns the size of the surface, in pixels.</p>
<p>Example:</p>
<pre><code>
const int_point_type&amp; GetSize( void )
{
    return m_size;
}
</code></pre><p><b>Blit</b></p>
<p>This method is used to paint the result of a raster painter into a surface. This is a template method, which must accept an arbitrary raster painter type.</p>
<p>Example:</p>
<pre>
<code>
    template&lt;typename raster_painter_type&gt;
    void Blit( MyApplicationTraits::context_type&amp; context,
        const Constraints&amp; constraints,
        RasterMachine&lt;typename raster_painter_type::signal_traits&gt;&amp; machine,
        const int_point_type&amp; location,
        raster_painter_type&amp; rp,
        const region_type&amp; clip ) const
    {
        // This structure describes a little-endian surface with 16 bits per pixel,
        // 5 bits red, 6 bits green, 5 bits blue.  This data type is used as a template
        // parameter to BlitToSurface to create a function capable of playing the given
        // RasterPainter into a memory buffer with these characteristics.
        struct MySurfaceTraits
        {
            typedef MyApplicationTraits app_traits;
            static constexpr bool array_like = false;

            typedef short block_type;
            static constexpr size_t pixels_per_block = 1;
            static constexpr size_t pad_bits = 0;
            static constexpr size_t num_components = 3;
            static constexpr size_t bits_per_pixel = 16;
            static constexpr bool little_endian = true;

            typedef ComponentSize3&lt;5, 6, 5&gt; component_sizes;
        };

        BlitToSurface&lt;MySurfaceTraits, raster_painter_type&gt;( context, constraints, machine, location, rp, clip, m_bounds, m_bits, m_scanLineStride );
    }
</code>
</pre><p>Blitting a RasterPainter is an extremely complicated operation; Haiku provides a template function called "BlitToSurface" which takes the display characteristics, the base address and scan line stride of the buffer, and the various other parameters to <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a886e065e1df72ede1ab25b762805b1be">Blit()</a>, and renders the RasterPainter into the surface at the specified location through the specified clip. All implementations of <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a886e065e1df72ede1ab25b762805b1be">Blit()</a> should use <a class="el" href="namespacetetraphilia_1_1imaging__model.html#a61427589f930cc4d2340a949b9d3589d">BlitToSurface()</a>. </p>
</div><hr/>The documentation for this interface was generated from the following file:<ul>
<li>C:/GIT/t4/t4/tetraphilia/imaging_model/<a class="el" href="surfacesupport_8hpp_source.html">surfacesupport.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="interface___c_o_n_c_e_p_t__surface.html">_CONCEPT_surface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
