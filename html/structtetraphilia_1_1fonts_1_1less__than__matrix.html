<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>T4 API Reference ALL: tetraphilia::fonts::less_than_matrix Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="acrobaticon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">T4 API Reference ALL
   &#160;<span id="projectnumber">00.1 Beta</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structtetraphilia_1_1fonts_1_1less__than__matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structtetraphilia_1_1fonts_1_1less__than__matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tetraphilia::fonts::less_than_matrix Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html">Font.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c341133672078a8c6254e34d3b0b33e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix &gt; </td></tr>
<tr class="memitem:a3c341133672078a8c6254e34d3b0b33e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structtetraphilia_1_1fonts_1_1less__than__matrix.html#a3c341133672078a8c6254e34d3b0b33e">operator()</a> (Matrix const &amp;<a class="el" href="stdstr1_8h.html#a9336ebf25087d91c818ee6e9ec29f8c1">x</a>, Matrix const &amp;<a class="el" href="stdstr1_8h.html#a2fb1c5cf58867b5bbc9a1b145a86f3a0">y</a>) const</td></tr>
<tr class="separator:a3c341133672078a8c6254e34d3b0b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">runtime polymorphic base class for all "font" objects.

A font is an object which supports certain functions related to glyph rasterizing, glyph outlines
and encoding.  Font is a pure-virtual base class with several concrete subclasses.

&lt;b&gt;Encoding Services&lt;/b&gt;
"Encoding" is the name given to the general problem of associating glyphs in a font with bytes in a string
that you are trying to display.  Different font technologies use different basic strategies for how this
encoding works.  The three different strategies that are supported in this design are:

&lt;em&gt;kType1Encoding.&lt;/em&gt;  This strategies comes from the original PostScript design.  It requires that
the font itself associate names with each glyph.  When a string is drawn it is drawn using some "encoding
vector" which is a mapping from bytes in the string to associated glyph names.  This coupled with the
requirement that the glyphs in the font are associated with names allows the drawing code to determine
what glyphs need to be drawn.

&lt;em&gt;kTrueTypeEncoding.&lt;/em&gt;  This strategy comes from the Apple-defined TrueType font format.  In this strategy
the font contains a number of "cmap" tables which are mappings directly from bytes in a string to glyphs
in the font.  These "cmap" tables are identified with universaly-defined constants.  For example there
is a constant that implies "Macintosh, Roman" encoding, and other constants that imply "Microsoft, Unicode-based",
etc...

&lt;em&gt;kCIDEncoding.&lt;/em&gt;  This strategy comes from Adobe's CID-Keyed font design.  In this strategy there are
universally defined "character collections" that associate numeric values with particular characters.  It is
very similar to the Unicode strategy, except that the CID strategy allows for an arbitrary number of these
Unicode-like mappings.  In this case each mapping is given a universally-defined set of names to identify it.
For example, "Adobe Japan1" is one such set of names.

&lt;em&gt;kUnicodeEncoding.&lt;/em&gt;  This encoding stands for all font files available on the system which can be
accessed through a Unicode cmap. If no unicode cmap is present in a system font file, then we do not use it.
The glyph codes are first converted to unicode through some static tables built into the application and then
these unicode code points index into a pre-selected cmap from the system font file.

An instance of a Font object supports the GetEncodingType method which always returns one of the above three
values.  The client of a Font object can call this and then adopt one of several strategies when converting
bytes in a string into glyph identifies that are meaningful for the given font.

If the Font object reports either kType1Encoding or kTrueTypeEncoding then it supports several additional
services to allow the client to appropriately deal with the encoding problems for that font.  When a font
reports kType1Encoding for its encoding type, then it supports two additional APIs.  These are
GetType1GlyphNames and GetType1DefaultEncoding.  GetType1GlyphNames returns an array of pointers to null-terminated
strings.  The length of this array is the number of glyphs in the font.  The order of the names in this
array matches the order of the glyphIDs.  That is, the name for the glyph with glyphID = 7 is the name
in position 7 of the returned array.  Given an encoding vector (an array of 256 names that represent
the intended encoding of a string), you can call this GetTypeGlyphNames function, and then match each
of the names in your encoding vector to one in the returned array to allow you to build an array of
256 glyphIDs.  This sort of array lets you very quickly turn the bytes in a string into an array of
glyphIDs for the glyphs that are supposed to be displayed for that string.

Fonts that use kType1Encoding also support a notion of a "default" encoding.  In PostScript this corresponds
to the state of a font before you have applied an encoding vector to it.  In PDF there is a similar case
where some parts of a font's "default" encoding are used.  For these uses, these Type1 Fonts support
the GetType1DefaultEncoding function.  It returns a 256-long array of glyph names.

Unlike Type1 fonts, Fonts that use kTrueTypeEncoding can only support one of the encodings that are
build into the font itself (one that is specified by one of the font's "cmap" tables).  PDF essentially
only allows text that is drawn using a TrueType font to use one of the encodings that is built into that
font.  These Fonts support the GetTrueTypeEncodingTable function which takes some parameters providing
a high-level description of what encoding you are looking for (for example, "MacRoman") and returns
an array of 256 glyphIDs.  This array is the mapping from bytes in a string to glyphIDs for that font.
So it is simpler to make use of these TrueType fonts, but they support less flexibility.

Fonts that report either kType1Encoding or kTrueTypeEncoding are only used for text that uses some
kind of single-byte encoding.  Text that uses some kind of multi-byte encoding either uses CID-Keyed
fonts, or it uses some external mechanism to translate bytes in a string into glyphIDs for that font.

&lt;b&gt;Glyph Retrieval Services&lt;/b&gt;

There are two basic sets of glyph retrieval services in Font objects.  You can either get the outline
path, or a rasterized bitmap of any glyph in a Font.  Both of these services take glyphIDs as the
input parameter to specify what glyph you are interested in.  The section above describes various
ways of translating bytes in a string into glyphIDs for the font in question.  The Font object provides
a built-in caching mechanism for both outlines and bitmaps, so calling for the same outline or glyph
a second time is usually a very inexpensive operation.

The basic mechanism for getting glyph bitmaps is to first call the Font's GetCache method.  This method
takes a single matrix which will be used to scale the characters.  For example, the matrix {12, 0, 0, 12, 0, 0}
will, for most fonts, produce characters that look 12-points tall (that is, if you draw the bitmaps into
a bitmap that is 72 pixels per inch, the glyphs will appear to be 12-points tall).  GetCache returns
an object of type BitmapCache.  This BitmapCache object contains the method named GetBitmap which takes
a glyphID (but no matrix) and returns the bitmap for that glyph, rasterized at the matrix given to
the BitmapCache's constructor.

Not all Font's support glyph outlines.  To determine if a particular one supports them you call the Font's
SupportsOutlines method.  If this returns true you can call the Font's GetUnhintedGlyphOutline method.
The "unhinted" term is indicating that no pixel-based hinting has been applied to the outlines that are
returned.  This means that they are reasonably-well suited for scaling with any matrix.  These scaled,
but unhinted outlines, will be similar to, but not exactly the same as the outlines used during BitmapCache::GetBitmap.
If the Font does not support outlines it is an error to call its GetUnhintedGlypyOutline method.

&lt;b&gt;Recipe For Implementing Your Own Font Subclass&lt;/b&gt;

The basic steps are:

&lt;b&gt;1)&lt;/b&gt; Implement a subclass of tetraphilia::fonts::BitmapCache.  This forces you to provide an implementation
of the RasterizeBitmap method.  This is the method that is called when the requested glyph bitmap is
not already in the cache.

&lt;b&gt;2)&lt;/b&gt; Implement a subclass of tetraphilia::fonts::Font.  This forces you to provide implementations
of several methods that are involved in you providing bitmaps and outlines for your font.

Here is an example implementation:
</pre> <pre>
<code>
template&lt;typename app_traits&gt;
class MyBitmapCache : public tetraphilia::fonts::BitmapCache&lt;app_traits&gt;
{
public:
   MyBitmapCache( typename app_traits::context_type&amp; context,
                   const tetraphilia::fonts::Font&lt;app_traits&gt;* font,
                   const matrix_type&amp; mat,
                   <span style="color:green;">-- any additional argments you need</span>
                )
     : tetraphilia::fonts::BitmapCache&lt;app_traits&gt;( context, font, mat )
   {
     <span style="color:green;">-- any additional initialization you need</span>
   }

   <span style="color:green;">// we need to implement this</span>
   virtual <a class="el" href="classtetraphilia_1_1fonts_1_1_bitmap.html">tetraphilia::fonts::Bitmap</a>* RasterizeBitmap( const <a class="el" href="structtetraphilia_1_1fonts_1_1_bitmap_cache_key.html">BitmapCacheKey</a>&amp; key, const typename <a class="el" href="classtetraphilia_1_1fonts_1_1_font.html#ad51efb451ca2bbc9142005d3e4c4f35b">tetraphilia::fonts::Font&lt;app_traits&gt;::ptr_type</a>&amp; font,
        t4::transient_heap_sync&amp; heap )
   {
      <span style="color:green;">// "gid" is part of "key", and can be retrieved with key.GetGid()
      // if this font is a double-byte font, then "gid" is actually a CID in the
      // character collection being used by this font.  For example, if the text
      // is Japanese, the gid is very likely to be a CID in Adobe, Japan1.
      // if the font is a single byte font, the gid will be a glyph ID whose meaning
      // is defined by the font itself.

      // Also, key.GetClipRect() may either be NULL or pointing to a valid constraints bounds.
      // if it is non-NULL then the constraints represents the clip bounds in which this glyph
      // will be used.  This field is only passed with a non-NULL value in the case where the
      // glyph size is so large that Haiku will never attempt to cache glyphs for this <a class="el" href="classtetraphilia_1_1fonts_1_1_bitmap_cache.html">BitmapCache</a>.
      // In this case you may be able to save some memory by not attempting to produce pixel values
      // outside of this constraints.  When this is non-NULL its coordinates are relative to a
      // glyph drawn at the origin</span>

      // "suppressCaching" is used in GPU builds to indicate that the glyph's resulting bitmap
      // should not be cached, even if the <a class="el" href="classtetraphilia_1_1fonts_1_1_bitmap_cache.html">BitmapCache</a>'s glyph size is small enough that caching
      // is reasonable.  This boolean should be forwarded to any invocation of AllocateBitmap, which
      // implementations of RasterizeBitmap() should use to allocate memory for the bitmap.

      <span style="color:green;">// start by computing the bounding box for the glyph</span>
      typename app_traits::int_geometry_traits::rect_type bounds = &lt; some computation -- maybe involving "constraints" &gt;;

      <span style="color:green;">// we are required to allocate the storage for the bitmap with this call</span>
      <a class="el" href="classtetraphilia_1_1fonts_1_1_bitmap.html">tetraphilia::fonts::Bitmap</a>* b = this-&gt;AllocateBitmap( key, bounds, heap );

      <span style="color:green;">// now fill in the b-&gt;bits array with pixel values.  The length of the array
      // is equal to the width * height of the bounds you passed to AllocateBitmap
      // Any zero in the array corresponds to a pixel that is completely outside
      // the glyph's shape.  Any 0xff corresponds to a pixel that is completely
      // inside the shape.  Any value in between corresponds to a pixel on the edge
      // of the glyphs shape where the value should represent the percentage of
      // the pixel that is covered by the glyph's shape.</span>

      return b;
   }

};

template&lt;typename app_traits&gt;
class MyFont : public tetraphilia::fonts::Font&lt;app_traits&gt;
{
public:
   MyFont( typename app_traits::context_type&amp; context,
           <span style="color:green;">-- any additional arguments you need</span>
          )
     : tetraphilia::fonts::Font&lt;app_traits&gt;( context, t4::data_store() )
   {
     <span style="color:green;">-- any additional initialization you need</span>
   }

   virtual bool SupportsOutlines() const
   {
      <span style="color:green;">// in this example, we are showing a case where the font does not support outlines</span>
      return false;
   }

   virtual size_t GetNumGlyphs() const
   {
      <span style="color:green;">// if this font is a double-byte font, then the number of "glyphs" is really
      // the number of CID's, or one greater than the highest CID value that this font accepts.
      // if this font is a single-byte font, then it is the number of glyphs,
      // or one greater than the highest glyphID value that this font accepts</span>
      return &lt; some number &gt;;
   }

   virtual const typename app_traits::real_geometry_traits::matrix_type&amp; GetFontMatrix() const
   {
      <span style="color:green;">// for outline enabled fonts, this returns the matrix that maps from the
      // space in which the outlines are defined, into default-user space.
      // for example, CID and TrueType fonts are frequently defined internally
      // on a 1000 em square.  These fonts would have a font matrix that was
      // {1/1000, 0, 0, 1/1000, 0, 0}
      // since this example doesn't support outlines, this method will never be called</span>
      return &lt; the matrix &gt;;
   }

   virtual typename <a class="el" href="classtetraphilia_1_1fonts_1_1_font.html#aefc1bfeed1522e779c098c1a3f8ba9e7">tetraphilia::fonts::Font&lt;app_traits&gt;::EncodingType</a> GetEncodingType() const
   {
      <span style="color:green;">// in this example we are showing a Japanese based font.
      // since that is double-byte, the encoding type is always kCIDEncoding;</span>
      return <a class="el" href="classtetraphilia_1_1fonts_1_1_font.html#aefc1bfeed1522e779c098c1a3f8ba9e7a8c1ec1b01ad1cf29a7254e7ca7ead9a3">tetraphilia::fonts::Font&lt;app_traits&gt;::kCIDEncoding</a>;
   }

   virtual const char* const* GetType1GlyphNames() const
   {
      <span style="color:green;">// since we reported that we use CID encoding, this will never be called</span>
      return 0;
   }

   virtual const char* const* GetType1DefaultEncoding() const
   {
      <span style="color:green;">// since we reported that we use CID encoding, this will never be called</span>
      return 0;
   }

   virtual const std::uint16_t* GetTrueTypeEncodingTable( typename tetraphilia::fonts::Font&lt;app_traits&gt;::NamedEncoding namedEncoding, bool isSymbolic ) const
   {
      <span style="color:green;">// since we reported that we use CID encoding, this will never be called</span>
      return 0;
   }

   virtual <a class="el" href="namespacet4.html#ad8211a44f16a520bf2e375d5c9c96ec7">t4::bezier_path</a> ParseUnhintedGlyphOutline( path, size_t glyphID  )
   {
      <span style="color:green;">// since we reported that we don't support outlines, this will never be called</span>
   }

   virtual SubpixelPositionPolicy&lt;app_traits&gt;* NewSubpixelPositionPolicy( const matrix_type&amp; mat )
   {
      return SubpixelPositionPolicy&lt;app_traits&gt;( mat );
   }

   virtual <a class="el" href="classt4_1_1sptr.html">t4::sptr</a>&lt;BitmapCache&lt;app_traits&gt;&gt; NewBitmapCache( cache&lt;...&gt; const* cache,
        const matrix_type&amp; mat )
   {
      // Create a <a class="el" href="classtetraphilia_1_1fonts_1_1_bitmap_cache.html">BitmapCache</a> instance for the given matrix.  If cache is non-null, create the
      // bitmap cache in it.
      if ( cache )
        return <a class="el" href="namespacet4.html#a63afcb1bf6290e059f28f34266d52a24">t4::make_cache_entry</a>&lt;MyBitmapCache&lt;app_traits&gt;&gt;( mat, this, mat );
      return <a class="el" href="namespacet4.html#a40fd4ba48b879c2a0a7f0f050390b8eb">t4::make_shared</a>&lt;MyBitmapCache&lt;app_traits&gt;&gt;(this, mat);
   }

   virtual const typename app_traits::real_geometry_traits::rect_type&amp; GetMaximumGlyphBounds() const
   {
      <span style="color:green;">
      // return a bounding box that is the union of the bounding boxes of all
      // of the glyphs in this font, were the font drawn with an identity matrix.
      // this bounding box will be mapped by the current transformation matrix and
      // font size and then intersected with the current clip to determine whether
      // any of the text in the string will display.</span>
      return &lt; some bounds &gt;;
   }


};

</code>
</pre> 
<p class="definition">Definition at line <a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html#l00761">761</a> of file <a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html">Font.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c341133672078a8c6254e34d3b0b33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c341133672078a8c6254e34d3b0b33e">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tetraphilia::fonts::less_than_matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">Matrix const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html#l00764">764</a> of file <a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html">Font.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/GIT/t4/t4/tetraphilia/fonts/<a class="el" href="tetraphilia_2fonts_2font_8hpp_source.html">Font.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetetraphilia.html">tetraphilia</a></li><li class="navelem"><a class="el" href="namespacetetraphilia_1_1fonts.html">fonts</a></li><li class="navelem"><a class="el" href="structtetraphilia_1_1fonts_1_1less__than__matrix.html">less_than_matrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
